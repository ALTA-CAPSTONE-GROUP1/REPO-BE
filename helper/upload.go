package helper

import (
	"context"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"os"
	"time"

	"github.com/ALTA-CAPSTONE-GROUP1/e-proposal-BE/app/config"
	"github.com/cloudinary/cloudinary-go/v2"
	"github.com/cloudinary/cloudinary-go/v2/api/uploader"
	"github.com/phpdave11/gofpdf"
	fpdi "github.com/phpdave11/gofpdf/contrib/gofpdi"
)

type Upload struct {
}

type UploadInterface interface {
	UploadFile(fileContents *multipart.FileHeader, path string) ([]string, error)
}

func New() UploadInterface {
	return &Upload{}
}
func (u Upload) UploadFile(fileContents *multipart.FileHeader, path string) ([]string, error) {

	var urls []string
	uploadResult, err := u.doUpload(fileContents, path)
	if err != nil {
		return nil, err
	}
	urls = append(urls, uploadResult.SecureURL)
	return urls, nil
}

func (u Upload) doUpload(content *multipart.FileHeader, path string) (*uploader.UploadResult, error) {
	cld, err := cloudinary.NewFromParams(config.CloudinaryName, config.CloudinaryApiKey, config.CloudinaryApiScret)
	if err != nil {
		return nil, err
	}
	contentmulti, err := content.Open()
	if err != nil {
		panic(err)
	}
	defer contentmulti.Close()

	overwrite := true
	useFileName := true
	useFileNameDisplay := true
	uploadParams := uploader.UploadParams{
		PublicID:                 "epropProject",
		Folder:                   config.CloudinaryUploadFolder + path,
		UseFilename:              &useFileName,
		Overwrite:                &overwrite,
		UseFilenameAsDisplayName: &useFileNameDisplay,
	}

	uploadResult, err := cld.Upload.Upload(context.Background(), contentmulti, uploadParams)
	if err != nil {
		return nil, fmt.Errorf("error in uploadin file %w", err)
	}
	return uploadResult, nil
}

func UpdateCreateSign(current_link string, currentFileName string, approverName string, submissionTitle string, signName string, approverPosition string, action string, action_message string) (*multipart.FileHeader, error) {
	filePath := "downloaded.pdf"
	response, err := http.Get(current_link)
	if err != nil {
		return nil, err
	}
	defer response.Body.Close()

	file, err := os.Create(filePath)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	_, err = io.Copy(file, response.Body)
	if err != nil {
		return nil, err
	}

	pdf := gofpdf.New("P", "mm", "A4", "")
	pdf.AddPage()
	pdf.SetFont("Arial", "B", 18)
	pdf.CellFormat(0, 20, submissionTitle, "1", 1, "LT", false, 0, "")
	pdf.Ln(10)
	pdf.SetFont("Arial", "", 12)
	text := fmt.Sprintf("There is an update for your submission %s, by %s", action, approverName)
	pdf.MultiCell(0, 10, text, "", "L", false)
	pdf.Ln(5)
	pdf.CellFormat(0, 25, fmt.Sprintf("With note: %s", action_message), "", 1, "L", false, 0, "")
	pdf.MultiCell(0, 10, "This page is Generated by sistem check in eprop application", "", "L", false)
	pdf.Ln(5)
	pdf.CellFormat(0, 10, fmt.Sprintf("SignID: %s", signName), "1", 1, "L", false, 0, "")
	pdf.Ln(10)
	pdf.SetFont("Arial", "", 10)

	footerText := fmt.Sprintf("Generated at: %s", time.Now().Format("2006-01-02 15:04:05"))
	pdf.CellFormat(0, 10, footerText, "", 0, "R", false, 0, "")
	err = pdf.OutputFileAndClose("output.pdf")
	if err != nil {
		return nil, err
	}
	mergePDFs("merged.pdf", filePath, "output.pdf")

	defer os.Remove("merged.pdf")
	defer os.Remove("output.pdf")
	defer os.Remove(filePath)
	merged, err := os.Open("merged.pdf")
	if err != nil {
		return nil, err
	}

	defer merged.Close()
	fileHeader := &multipart.FileHeader{}
	return fileHeader, nil
}

func mergePDFs(outputFile string, files ...string) error {
	pdf := gofpdf.New("P", "mm", "A4", "")

	for _, file := range files {
		importedFile := fpdi.ImportPage(pdf, file, 1, "/MediaBox")
		pdf.AddPage()
		pdf.SetFont("Arial", "", 12)
		fpdi.UseImportedTemplate(pdf, importedFile, 20, 50, 150, 0)
	}

	return pdf.OutputFileAndClose(outputFile)
}
